# 虚拟机在java堆中对象分配、布局和访问的过程
## 一、 对象的创建  

### 从java程序，new指令开始
### 类加载  
 
  -  
### 类加载通过后，内存分配

  - 对象所需内存的大小在类加载完成后就可以完全确定，为对象分配空间的任务等于把一块确定大小的内存从Java堆中划分出来。 
  - 两种方法：
    + 指针碰撞
      > 假如，java堆中内存是绝对规整的，所有用过的内存和空闲的内存分为两部分，中间放一个指针作为分界点的指示器，那分配内存   
        就是把指针向空闲空间那边挪动一段与对象大小相当的距离。
    + 空闲列表
      > 假如，java堆中的内存并不是规整的，已使用的内存和空间的内存相互交错，如此虚拟机就必须维护一个列表，记录上哪些内存块是可用的，   
        在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
  - 分配方式的选择取决于：java堆是否规整;Java堆是否规整取决于：所采用的垃圾收集器是否带有*压缩整理功能*。
  - 实例
    + 在使用Serial、ParNew等带有Compact过程的收集器时，系统采用分配算法为：指针碰撞;
    + 使用CMS，基于 Mark-Sweep算法的收集器时，系统采用分配算法为：空闲列表。
### 对象创建的线程安全问题
  - 问题描述
    > 对象创建在虚拟机中的行为非常频繁，即使只是修改一个指针所指向的位置，在并发情况下也并不是线程安全的，有可能出现正在给对象A分配   
      内存，指针还没有修改，对象B又同时使用了原来的指针来分配内存的情况。
  - 解决方法，有两种:
    + 1 对分配空间的动作进行同步处理
      > 实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性;
      - CAS（比较与交换，Compare and swap）是一种有名的无锁算法。（ConcurrentHashMap也用到了此算法）
    + 2 本地线程分配缓冲
      > 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（Tlab）。   
        哪个线程要分配内存，就在哪个线程的Tlab上分配，只有Tlab用完并分配新的Tlab时，才需用同步锁定。     
      - 虚拟机是否使用Tlab,可以通过-XX：+/-UseTlab参数来设定
###  对象内存分配完成后，虚拟机把内存空间初始化
   
   - 虚拟机将分配到的内存空间都初始化为零值（不包括对象头），如果使用Tlab,初始化操作可以提前至Tlab分配时进行。
   - 目的：
     > 保证了对象的实例字段在java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的的零值。
###  修饰对象   

   - 虚拟机对对象进行必要的设置。其实是对象头。
   - 对象头中包括：对象的哈希码、对象的Gc分代年龄、此对象是哪个类的实例、类的元数据信息的指示等；
   - 根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
### 从虚拟机的角度，一个新的对象已经产生。
### 从java程序的角度，对象创建才刚刚开始，init方法还没有执行，所有的字段都为零。
   
   - 一般来说（由字节码中是否跟随invokespecial指令所决定），执行new 指令之后会接着执行<init>方法，   
     把对象按照程序员的意愿进行初始化，这样一个真正可用的对象产生。
## 二、 对象的内存布局
### 布局分配分为三个部分  
   
   - 对象头
   - 实例数据
   - 对齐填充
   