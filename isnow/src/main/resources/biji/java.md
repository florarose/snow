# 垃圾收集器与内存分配策略
## 一、 GC要做的事情
  1. 哪些内存需要回收 ？  
  2. 什么时候回收 ？
  3. 如何回收 ？   
##二、 什么时候需要GC ? 
  1. 内存溢出、内存泄漏等;
  2. 垃圾收集收成系统达到更*高并发量*的瓶颈时。
## 三、 正文
### 1 哪些内存需要回收 ？
  1. 基本不考虑
     + 部分: 程序计数器、虚拟机栈、本地方法栈
     + 原因: 在编译期基本确定了内存大小
  2. 主要考虑
     + 部分: Java堆和方法区
     + 原因: 运行期间动态分配内存。
### 2 什么时候回收 ？
   - **答: 对象已死的时候**
   #### 问题来了，如何判断对象已死 ？
   1. 引用计数算法
      - 定义: 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1;当引用失效时，计数器值就减1；  
              任何时刻计数器为0的对象就是不可能再被使用的。
      - 好处: 实现简单，效率高
      - 缺陷: 很难解决对象之间互相循环引用的问题
   2. 可达性分析算法
      - 定义： 通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用连，   
                当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
      - java中，GC Roots对象
        + 虚拟机栈（栈帧中的本地变量表）中引用的对象
        + 方法区中类静态属性引用的对象
        + 方法区中常量引用的对象
        + 本地方法栈中JNI(即Native方法)引用的对象
   3. 引用
      - 第一和第二种算法判定对象是否存活都与**引用**有关。
      - JDK 1.2 后，引用有了新的定义,以下顺序引用由强变弱
        + 强引用(Strong Reference)
          > Object obj = new Object(); 程序中类似这样的就是强引用。  
            强引用存在，垃圾收集器永远不会回收掉被引用的对象
        + 软引用(Soft Reference)
          > 软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进 回收范围之中进行第二次回收；  
            如果第二次回收后还没有足够的内存，才会抛出内存溢出异常。
        + 弱引用(Weak Reference)
          > 弱引用关联的对象，只能生存到下一次垃圾收集发生之前。  
            垃圾收集器工作时，被回收。
        + 虚引用(Phantom Reference)
          > 虚引用存在的唯一意义： 在对象被回收的时候，收到一个系统通知；  
            无法获取对象实例。
      - 补充：
        + 强引用是普遍存在。
        + 软引用和弱引用都是用来描述**非必须的对象**。
        + 虚引用又称为幽灵引用或者幻影引用。
   4. 生存还是死亡 ？
      - 需要注意的是，通过可达性分析算法得到的不可达的对象，也不是非死不可的。
      - 一个对象的死亡，至少经历两次标记过程：
        + 可达性分析不可达的对象，被第一次标记并且进行一次**筛选**；
        + 筛选被判定有必要执行finalize()方法，进入 F-Queue的队列，等待被执行该方法。
